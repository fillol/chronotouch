#!/bin/bash

# Script that reads filenames in a folder, interpreting the date (if present), and changes their timestamp.
# First tries to extract the date from EXIF metadata (if available and for IMG/VID), otherwise uses the date from the filename.
# Developed for photos and videos with prefixes IMG, VID, PANO and screenshots.

# VARIABLE FOR DRY-RUN (SIMULATION) MODE
DRY_RUN=false

# Function to extract the date from the filename
extract_date_from_filename() {
    local filename="$1"
    local extracted_date_filename=""

    if [[ "$filename" =~ ^IMG([0-9]{8})([_-]?)([0-9]{4}) ]]; then # IMG-YYYYMMDD-HHMM or IMG_YYYYMMDD_HHMM or IMGYYYYMMDDHHMM
        extracted_date_filename="${BASH_REMATCH[1]}${BASH_REMATCH[3]}"
    elif [[ "$filename" =~ ^IMG([0-9]{8})WA[0-9]+ ]]; then   # IMG-YYYYMMDD-WA... (whatsapp no time)
        extracted_date_filename="${BASH_REMATCH[1]}0000" # Set time to 00:00
    elif [[ "$filename" =~ ^VID([0-9]{8})([_-]?)([0-9]{4}) ]]; then # VID-YYYYMMDD-HHMM or VID_YYYYMMDD_HHMM or VIDYYYYMMDDHHMM
        extracted_date_filename="${BASH_REMATCH[1]}${BASH_REMATCH[3]}"
    elif [[ "$filename" =~ ^PANO([0-9]{8})([_-]?)([0-9]{4}) ]]; then # PANO-YYYYMMDD-HHMM or PANO_YYYYMMDD_HHMM or PANOYYYYMMDDHHMM
        extracted_date_filename="${BASH_REMATCH[1]}${BASH_REMATCH[3]}"
    elif [[ "$filename" =~ ^Screenshot_([0-9]{8})_([0-9]{6}) ]]; then # Screenshot_YYYYMMDD_HHMMSS
        extracted_date_filename="${BASH_REMATCH[1]}${BASH_REMATCH[2]:0:4}" #YYYYMMDDHHmm (truncates seconds)
    fi

    if [[ -n "$extracted_date_filename" ]]; then # Check if date was extracted
        if [[ ${#extracted_date_filename} -eq 8 ]] || [[ ${#extracted_date_filename} -eq 12 ]]; then
            if [[ "$extracted_date_filename" =~ ^[0-9]+$ ]]; then
                echo "$extracted_date_filename"
                return 0 # Date extracted successfully
            fi
        fi
    fi
    return 1 # Date extraction failed or invalid date
}

# Function to extract the date from EXIF metadata (unchanged)
extract_date_from_exif() {
    local filename="$1"
    local extracted_date_exif=$(exiftool -s -s -n -CreateDate "$filename" 2>/dev/null) # 2>/dev/null to suppress errors if exiftool is not installed or date not found
    if [[ -n "$extracted_date_exif" ]]; then
        # EXIF Format:YYYY:MM:DD HH:MM:SS orYYYY:MM:DD HH:MM:SSÂ±HH:MM
        # Convert to YYYYMMDDHHmm format required by touch -t
        extracted_date_exif=$(date -d "$extracted_date_exif" +%Y%m%d%H%M 2>/dev/null) # 2>/dev/null to handle invalid date errors
        if [[ -n "$extracted_date_exif" ]] && [[ "$extracted_date_exif" =~ ^[0-9]{12}$ ]]; then
            echo "$extracted_date_exif"
            return 0 # EXIF date extracted and converted successfully
        fi
    fi
    return 1 # EXIF date extraction failed or invalid date
}


# Script argument handling and dry-run option (unchanged)
while [[ $# -gt 0 ]]; do
    case "$1" in
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        --help|-h)
            echo "Usage: $0 [-n|--dry-run] [folder]"
            echo ""
            echo "  Execute the script without arguments in the current folder."
            echo "  Options:"
            echo "    -n, --dry-run   Runs the script in simulation mode, without modifying timestamps."
            echo "    -h, --help      Shows this help message."
            echo "    [folder]      Recursively run the script on the specified folder."
            exit 0
            ;;
        *)
            break # Exit while loop to handle folder (if present)
            ;;
    esac
done


case "$#" in
    0 ) # First run (without folder argument) (unchanged)
    echo "Are you sure you want to change all timestamps in the current folder? Type YES to confirm."
    if [[ "$DRY_RUN" == true ]]; then
        echo "**WARNING:** Script in DRY-RUN (simulation) mode. No timestamps will be modified."
    fi
    read -r answer
    if [[ "$answer" != "YES" ]]; then
        echo "Operation cancelled."
        exit 1
    fi
    ;;
    1 ) # Recursive run with subfolder as argument (unchanged)
    if [[ ! -d "$1" ]]; then
        echo "Error: '$1' is not a valid folder."
        exit 1
    else
        cd "$1" || { echo "Error: cannot access '$1'"; exit 1; } # Exit on cd error
    fi
    ;;
    *) # Argument number error (after option handling) (unchanged)
    echo "Usage: $0 [-n|--dry-run] [folder]"
    echo "Run '$0 --help' for more information."
    exit 1
    ;;
esac

# Check for exiftool presence and warn user (once at the beginning) (unchanged)
if ! command -v exiftool &> /dev/null; then
    echo "Warning: exiftool is not installed. EXIF metadata date extraction will not be available."
    echo "Install exiftool for full functionality (e.g., sudo apt install libimage-exiftool-perl)."
fi


# Loop through all files and folders in the current folder (unchanged)
find . -maxdepth 1 -print0 | while IFS= read -r -d $'\0' item; do # find + while loop to handle filenames with spaces and special characters
    if [[ -d "$item" ]]; then
        if [[ "$item" != "." ]]; then # Avoid recursively calling the current folder "."
            "$0" "$item" # Recursively run the script for subfolders
        fi
    elif [[ -f "$item" ]]; then
        filename=$(basename "$item") # Get only the filename, not the path
        file_prefix=$(echo "$filename" | cut -c 1-4) # Prefix to identify file type

        extracted_date="" # Initialize extracted date variable

        if [[ "$file_prefix" == "IMG" ]] || [[ "$file_prefix" == "VID" ]]; then
            # Try EXIF first for IMG and VID
            if extract_date_from_exif "$filename"; then
                extracted_date=$(extract_date_from_exif "$filename")
                echo "EXIF date extracted from '$filename': $extracted_date"
            else
                if extract_date_from_filename "$filename"; then
                    extracted_date=$(extract_date_from_filename "$filename")
                    echo "Date from filename extracted from '$filename': $extracted_date (EXIF not available)"
                else
                    echo "No date found for '$filename'."
                fi
            fi
        elif [[ "$file_prefix" == "PANO" ]] || [[ "$filename" =~ ^Screenshot_ ]]; then # PANO or Screenshot: filename only
            if extract_date_from_filename "$filename"; then
                extracted_date=$(extract_date_from_filename "$filename")
                echo "Date from filename extracted from '$filename': $extracted_date"
            else
                echo "No date found for '$filename'."
            fi
        else
            echo "File '$filename' ignored (unrecognized prefix)."
        fi

        if [[ -n "$extracted_date" ]]; then # If a valid date was extracted
            if [[ "$DRY_RUN" == false ]]; then # If NOT in dry-run mode, modify timestamp
                if ! touch -t "$extracted_date" "$item"; then # Error check for touch
                    echo "Error: cannot change timestamp of '$item'."
                else
                    echo "Timestamp of '$item' changed to date: $extracted_date"
                fi
            else # If in dry-run mode, simulate modification
                echo "[SIMULATION] Timestamp of '$item' *would be* changed to date: $extracted_date"
            fi
        fi
    fi
done

echo "Script completed."
if [[ "$DRY_RUN" == true ]]; then
    echo "**DRY-RUN Mode:** No timestamps were actually modified."
fi
