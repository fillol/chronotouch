#!/bin/bash

# Script che legge i nomi di file in una cartella, interpretandone la data (se presente),
# e ne cambia il timestamp.
# Da eseguire senza argomenti.
# Sviluppato per foto e video con prefissi IMG, VID, PANO e screenshot.
# Prova prima ad estrarre la data dai metadati EXIF (se disponibile e per IMG/VID),
# altrimenti usa la data dal nome del file (se nel formato previsto).

# VARIABILE PER LA MODALITÀ DRY-RUN (SIMULAZIONE)
DRY_RUN=false

# Funzione per estrarre la data dal nome del file
extract_date_from_filename() {
    local filename="$1"
    local extracted_date_filename=""

    if [[ "<span class="math-inline">filename" \=\~ ^IMG\(\[0\-9\]\{8\}\)\(\[\_\-\]?\)\(\[0\-9\]\{4\}\) \]\]; then \# IMG\-YYYYMMDD\-HHMM o IMG\_YYYYMMDD\_HHMM o IMGYYYYMMDDHHMM
extracted\_date\_filename\="</span>{BASH_REMATCH[1]}${BASH_REMATCH[3]}"
    elif [[ "<span class="math-inline">filename" \=\~ ^IMG\(\[0\-9\]\{8\}\)WA\[0\-9\]\+ \]\]; then   \# IMG\-YYYYMMDD\-WA\.\.\. \(whatsapp senza ora\)
extracted\_date\_filename\="</span>{BASH_REMATCH[1]}0000" # Imposta l'ora a 00:00
    elif [[ "<span class="math-inline">filename" \=\~ ^VID\(\[0\-9\]\{8\}\)\(\[\_\-\]?\)\(\[0\-9\]\{4\}\) \]\]; then \# VID\-YYYYMMDD\-HHMM o VID\_YYYYMMDD\_HHMM o VIDYYYYMMDDHHMM
extracted\_date\_filename\="</span>{BASH_REMATCH[1]}${BASH_REMATCH[3]}"
    elif [[ "<span class="math-inline">filename" \=\~ ^PANO\(\[0\-9\]\{8\}\)\(\[\_\-\]?\)\(\[0\-9\]\{4\}\) \]\]; then \# PANO\-YYYYMMDD\-HHMM o PANO\_YYYYMMDD\_HHMM o PANOYYYYMMDDHHMM
extracted\_date\_filename\="</span>{BASH_REMATCH[1]}${BASH_REMATCH[3]}"
    elif [[ "<span class="math-inline">filename" \=\~ ^Screenshot\_\(\[0\-9\]\{8\}\)\_\(\[0\-9\]\{6\}\) \]\]; then \# Screenshot\_YYYYMMDD\_HHMMSS
extracted\_date\_filename\="</span>{BASH_REMATCH[1]}${BASH_REMATCH[2]:0:4}" #<ctrl3348>MMDDHHmm (tronca i secondi)
    fi

    if [[ -n "$extracted_date_filename" ]]; then # Verifica se la data è stata estratta
        if [[ ${#extracted_date_filename} -eq 8 ]] || [[ ${#extracted_date_filename} -eq 12 ]]; then
            if [[ "<span class="math-inline">extracted\_date\_filename" \=\~ ^\[0\-9\]\+</span> ]]; then
                echo "$extracted_date_filename"
                return 0 # Data estratta con successo
            fi
        fi
    fi
    return 1 # Estrazione data fallita o data non valida
}

# Funzione per estrarre la data dai metadati EXIF (invariata)
extract_date_from_exif() {
    local filename="<span class="math-inline">1"
local extracted\_date\_exif\=</span>(exiftool -s -s -n -CreateDate "$filename" 2>/dev/null) # 2>/dev/null per sopprimere errori se exiftool non è installato o non trova la data
    if [[ -n "<span class="math-inline">extracted\_date\_exif" \]\]; then
\# Formato EXIF\:<ctrl3348\>\:MM\:DD HH\:MM\:SS oMMDDHHmm richiesto da touch \-t
extracted\_date\_exif\=</span>(date -d "$exif_date_exif" +%Y%m%d%H%M 2>/dev/null) # 2>/dev/null per gestire errori di date non valide
        if [[ -n "$extracted_date_exif" ]] && [[ "<span class="math-inline">extracted\_date\_exif" \=\~ ^\[0\-9\]\{12\}</span> ]]; then
            echo "$extracted_date_exif"
            return 0 # Data EXIF estratta e convertita con successo
        fi
    fi
    return 1 # Estrazione data EXIF fallita o data non valida
}


# Gestione argomenti script e opzione dry-run (invariata)
while [[ $# -gt 0 ]]; do
    case "$1" in
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        --help|-h)
            echo "Utilizzo: <span class="math-inline">0 \[\-n\|\-\-dry\-run\] \[cartella\]"
echo ""
echo "  Esegui lo script senza argomenti nella cartella corrente\."
echo "  Opzioni\:"
echo "    \-n, \-\-dry\-run   Esegue lo script in modalità simulazione, senza modificare i timestamp\."
echo "    \-h, \-\-help      Mostra questo messaggio di aiuto\."
echo "    \[cartella\]      Esegui lo script ricorsivamente sulla cartella specificata\."
exit 0
;;
\*\)
break \# Esci dal ciclo while per gestire la cartella \(se presente\)
;;
esac
done
case "</span>#" in
    0 ) # Primo avvio (senza argomento cartella) (invariata)
    echo "Sicuro di voler cambiare tutti i timestamp nella cartella corrente? Scrivi YES per confermare."
    if [[ "$DRY_RUN" == true ]]; then
        echo "**ATTENZIONE:** Script in modalità DRY-RUN (simulazione). Nessun timestamp verrà modificato."
    fi
    read -r answer
    if [[ "$answer" != "YES" ]]; then
        echo "Operazione annullata."
        exit 1
    fi
    ;;
    1 ) # Avvio ricorsivo con sottocartella come argomento (invariata)
    if [[ ! -d "$1" ]]; then
        echo "Errore: '$1' non è una cartella valida."
        exit 1
    else
        cd "$1" || { echo "Errore: impossibile accedere a '$1'"; exit 1; } # Uscita in caso di errore cd
    fi
    ;;
    *) # Errore numero argomenti (dopo gestione opzioni) (invariata)
    echo "Utilizzo: $0 [-n|--dry-run] [cartella]"
    echo "Esegui '$0 --help' per maggiori informazioni."
    exit 1
    ;;
esac

# Controllo presenza exiftool e avviso utente (una sola volta all'inizio) (invariata)
if ! command -v exiftool &> /dev/null; then
    echo "Avviso: exiftool non è installato. L'estrazione della data dai metadati EXIF non sarà disponibile."
    echo "Installa exiftool per una funzionalità completa (es: sudo apt install libimage-exiftool-perl)."
fi


# Ciclo su tutti i file e cartelle nella cartella corrente (invariata)
find . -maxdepth 1 -print0 | while IFS= read -r -d $'\0' item; do # find + while loop per gestire nomi file con spazi e caratteri speciali
    if [[ -d "$item" ]]; then
        if [[ "$item" != "." ]]; then # Evita di richiamare ricorsivamente la cartella corrente "."
            "$0" "$item" # Avvia lo script ricorsivamente per le sottocartelle
        fi
    elif [[ -f "<span class="math-inline">item" \]\]; then
filename\=</span>(basename "<span class="math-inline">item"\) \# Ottieni solo il nome del file, non il percorso
file\_prefix\=</span>(echo "$filename" | cut -c 1-4) # Prefisso per identificare tipo file

        extracted_date="" # Inizializza la variabile data estratta

        if [[ "$file_prefix" == "IMG" ]] || [[ "$file_prefix" == "VID" ]]; then
            # Prova prima EXIF per IMG e VID
            if extract_date_from_exif "<span class="math-inline">filename"; then
extracted\_date\=</span>(extract_date_from_exif "$filename")
                echo "Data EXIF estratta da '$filename': $extracted_date"
            else
                if extract_date_from_filename "<span class="math-inline">filename"; then
extracted\_date\=</span>(extract_date_from_filename "$filename")
                    echo "Data dal nome file estratta da '$filename': $extracted_date (EXIF non disponibile)"
                else
                    echo "Nessuna data trovata per '$filename'."
                fi
            fi
        elif [[ "$file_prefix" == "PANO" ]] || [[ "$filename" =~ ^Screenshot_ ]]; then # PANO o Screenshot: solo nome file
            if extract_date_from_filename "<span class="math-inline">filename"; then
extracted\_date\=</span>(extract_date_from_filename "$filename")
                echo "Data dal nome file estratta da '$filename': $extracted_date"
            else
                echo "Nessuna data trovata per '$filename'."
            fi
        else
            echo "File '$filename' ignorato (prefisso non riconosciuto)."
        fi

        if [[ -n "$extracted_date" ]]; then # Se è stata estratta una data valida
            if [[ "$DRY_RUN" == false ]]; then # Se NON è in modalità dry-run, modifica il timestamp
                if ! touch -t "$extracted_date" "$item"; then # Controllo errore touch
                    echo "Errore: impossibile cambiare timestamp di '$item'."
                else
                    echo "Timestamp di '$item' cambiato con data: $extracted_date"
                fi
            else # Se è in modalità dry-run, simula la modifica
                echo "[SIMULAZIONE] Timestamp di '$item' *sarebbe* cambiato con data: $extracted_date"
            fi
        fi
    fi
done

echo "Script completato."
if [[ "$DRY_RUN" == true ]]; then
    echo "**Modalità DRY-RUN:** Nessun timestamp è stato effettivamente modificato."
fi
